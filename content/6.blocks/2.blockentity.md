---
title: Block Entity
description: Learn how to extend custom Block functionality using a BlockEntity.
---

With [Blockstates](/blocks/blockstates) you have already created "Pre-defined" and "finite" data for your Blocks.

For example, a Redstone Torch can be lit or unlit, an oak log can face six different directions and slabs can be waterlogged.

But how can you add data which may have near-endless possibilities, like the text on a sign or the inventory which is implemented in a chest?

## Overview of Block Entities

A `BlockEntitiy` is used to store custom data for blocks. Unlike the `Block`, they are bound to a world and have their own instantiated objects for each of their block positions. This is the reason why fields can be used to handle data inside of the object for as long as the object exists. Data can be stored as NBT, using `readNbt` and `writeNbt`, for a longer time.

BlockEntities are also used for custom rendering and can [handle ticks on the server side](/blocks/blockentity#implementing-blockentity-ticking) (instead of the `Block`'s client-sided random ticks).

## Creating the custom BlockEntity class

Create a new `TestBlockEntity` class in the `src/main/java/.../examplemodname/block/entity` folder, which extends from `BlockEntity`, and implement the constructor.

The constructor of the BlockEntity comes with three parameters `(type, pos, state)` by default. Make sure to remove the type parameter. Otherwise, the registration of the [BlockEntityType](/blocks/blockentity#registering-the-blockentity-with-a-blockentitytype) later on, with the class constructor reference (`TestBlockEntity::new`), won't work.

```java
public class TestBlockEntity extends BlockEntity {
    // make sure the constructor's parameters are correct!
    public TestBlockEntity(BlockPos pos, BlockState state) {
        // We will create this BlockEntityType later on.
        super(ExampleMod.TEST_BLOCK_ENTITY_TYPE, pos, state);
    }
}
```

## Preparing the custom Block class

There are two ways of adding a `BlockEntity` to a custom `Block`.

1. The custom Block class needs to implement the `BlockEntityProvider` interface
2. The custom Block class needs to extend from `BlockWithEntity`

Both ways require to `@Override` the `createBlockEntity` method. This is the only place where the custom `BlockEntity` class is instantiated.

```java
// This TestBlock has been registered in a custom class, called ExampleBlocks
// it is referenced as ExampleBlocks.TEST_BLOCK
// check the custom Block page, to see how to register your custom Blocks
public class TestBlock extends BlockWithEntity {    
    // instantiate your custom BlockEntity class
    @Nullable
    @Override
    public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {
        return new TestBlockEntity(pos, state);
    }
    // when extending from BlockWithEntity, it would be invisible by default
    // make sure to pass in the correct BlockRenderType
    @Override
    public BlockRenderType getRenderType(BlockState state) {
        return BlockRenderType.MODEL;
    }

    // ...
}
```

## Registering the BlockEntity with a BlockEntityType

Several Blocks can share the same functionality. For example all versions of the sign Blocks behave in the same way. It is possible to register multiple Blocks for a `BlockEntity` using a single `BlockEntityType`. Examples of this can be seen in the `BlockEntityType` class but the Fabric API registers them slightly differently.

Create the registry entry for the `BlockEntityType` in the `ModInitializer` implementing entry-point class and create a static reference for a `BlockEntityType` which has the custom `TestBlockEntity` class as a type parameter. This is used in the `TestBlockEntity`'s constructor.

Continue with the `BlockEntityType` registration in the `onInitialize()` method.

```java
public class ExampleMod implements ModInitializer {
    // This BlockEntityType is referenced in the TestBlockEntity's constructor
    public static BlockEntityType<TestBlockEntity> TEST_BLOCK_ENTITY_TYPE;

    @Override
    public void onInitialize() {
    // ...
    TEST_BLOCK_ENTITY_TYPE = Registry.register(
                Registries.BLOCK_ENTITY_TYPE, new Identifier(ExampleMod.MOD_ID, "test_block_entity"),
                FabricBlockEntityTypeBuilder.create(TestBlockEntity::new, ExampleBlocks.TEST_BLOCK)
                        // Add as many .addBlock(...) here, as needed to support
                        // additional blocks for the same custom BlockEntity
                        .build()
        );
    }
}
```

## Cleaning up the mess

Depending on how many Registry Entries there are, this can get messy quickly. To avoid that, add a new `ExampleBlockEntities` class in the `src/main/java/.../examplemodname/block/entity` folder and add a new method that will register all custom BlockEntityTypes.


```java
public class ExampleBlockEntities {
    public static BlockEntityType<TestBlockEntity> TEST_BLOCK_ENTITY_TYPE;

    public static void registerBlockEntityTypes() {        
        TEST_BLOCK_ENTITY_TYPE = Registry.register(
                Registries.BLOCK_ENTITY_TYPE, new Identifier(ExampleMod.MOD_ID, "test_block_entity"),
                FabricBlockEntityTypeBuilder.create(TestBlockEntity::new, ExampleBlocks.TEST_BLOCK).build()
        );        
        // Add more BlockEntityTypes here, if needed
    }
}
```

This way, the `ModInitializer` implementing entry-point class needs to only have one line to register all custom BlockEntities.

```java
public class ExampleMod implements ModInitializer {
    
    @Override
    public void onInitialize() {
        ExampleBlockEntities.registerBlockEntityTypes();
        // ...
    }
}
    
```

The reference in the `TestBlockEntity` class' constructor needs to be changed as well.

```java
public class TestBlockEntity extends BlockEntity {
    public TestBlockEntity(BlockPos pos, BlockState state) {
        super(ExampleBlockEntities.TEST_BLOCK_ENTITY_TYPE, pos, state);
    }
    // ...
}
```

## How to use the custom BlockEntity

In this example the custom `Block` class will be used to implement the functionality of the `Block` and its `BlockEntity` will be used to keep track of its data.

You can access the BlockEntity's object with `world.getBlockEntity(pos)` in your custom `Block` class.

```java
public class TestBlock extends BlockWithEntity {
    // ...
    
    // executed when entities fall on the custom Block
    @Override
    public void onLandedUpon(World world, BlockState state, BlockPos pos, Entity entity, float fallDistance) {
        // check for the custom BlockEntity
        if (world.getBlockEntity(pos) instanceof TestBlockEntity testBlockEntity && !world.isClient()) {

            // using the Accessor of the custom BlockEntity
            int count = testBlockEntity.getInteractionCount();
            // using the Mutator of the custom BlockEntity
            testBlockEntity.setInteractionCount(count + 1);            
            
            // value output for the player in the chat
            if (entity instanceof PlayerEntity) {
                entity.sendMessage(Text.literal("Stepped on for " + testBlockEntity.getInteractionCount() + " times."));
            }
        }
        super.onLandedUpon(world, state, pos, entity, fallDistance);
    }    
}
```

The custom `BlockEntity` will get additional methods and variables to interact with, and save the incoming data from the custom `Block` class.

```java
public class TestBlockEntity extends BlockEntity {
    // implementing an attribute for the object's custom data
    private int interactionCount = 0;
    // a static String variable to avoid typos when refering to the NBT data
    private static final String INTERACT_NBT_KEY = "test_block.interaction";

    public TestBlockEntity(BlockPos pos, BlockState state) {
        super(ExampleBlockEntities.TEST_BLOCK_ENTITY_TYPE, pos, state);
    }

    // "Accessor" (getter) method
    // to access this value from outside of this class
    public int getInteractionCount() {
        return this.interactionCount;
    }
    // "Mutator" (setter) method
    // to change this value from outside of this class
    public void setInteractionCount(int newCount) {
        this.interactionCount = newCount;        
        // When changing values for the BlockEntity, make sure to mark it as dirty.
        // Otherwise, the new values won't be saved properly in the NBT data
        this.markDirty();
    }

    // store data in the NBT of the BlockEntity
    @Override
    protected void writeNbt(NbtCompound nbt) {
        nbt.putInt(INTERACT_NBT_KEY, this.interactionCount);
        super.writeNbt(nbt);
    }
    // read data from the NBT of thew BlockEntity
    @Override
    public void readNbt(NbtCompound nbt) {
        super.readNbt(nbt);
        this.interactionCount = nbt.getInt(INTERACT_NBT_KEY);
    }
}
```

In this example, the `this` keyword has mostly been used in a non-essential context, but if you are not familiar with the `this` and `static` keywords, you should consider refreshing your Java OOP knowledge.

Now you have a custom `Block` which will interact with the player and save its data in the NBT using the custom `BlockEntity` and its `BlockEntityType` for registration.

## Implementing BlockEntity ticking

Create a new method that will be called for every tick inside of the custom `BlockEntity` class and implement your `tick` behavior. In this case, every 200 ticks (~ 10 sec) the `SoundEvents.BLOCK_ANVIL_USE` sound will be played.

In addition, create a new attribute to keep track of the ticks for the `BlockEntity` instance.

```java
public class TestBlockEntity extends BlockEntity {
    // the new field for the ticking
    // if the value is important to keep, consider saving this field into the NBT values too.
    private int tickCounter = 0;

    // ...

    public TestBlockEntity(BlockPos pos, BlockState state) {
        super(AcanthusPocketBlockEntities.TEST_BLOCK_ENTITY_TYPE, pos, state);
    }

    // ...

    public static void tick(World world, BlockPos pos, BlockState blockState, BlockEntity blockEntity) {
        // check if the blockEntity from the parameters is actualy this custom BlockEntity
        // you can also just work with a cast instead - we will check for the correct BlockEntity when calling this method anyways
        if (blockEntity instanceof TestBlockEntity testBlockEntity) {
            // play the sound every 200 ticks with the use of the modulo operator
            if (testBlockEntity.tickCounter % 200 == 0) {
                world.playSound(null, pos, SoundEvents.BLOCK_ANVIL_USE, SoundCategory.BLOCKS, 1f, 1f);
            }
            // increment the tick attribute of the instance
            testBlockEntity.tickCounter++;
        }
    }
}
```

Now `@Override` the `getTicker` method in the custom `Block` class to call the `BlockEntity`'s `tick` method.

```java
public class TestBlock extends BlockWithEntity {
    // ...

    @Nullable
    @Override
    public <T extends BlockEntity> BlockEntityTicker<T> getTicker(World world, BlockState state, BlockEntityType<T> type) {
        // calls the custom BlockEntity's tick method if the getTicker method parameter's BlockEntityType and the specified BlockEntityType match up
        return checkType(type, ExampleBlockEntities.TEST_BLOCK_ENTITY_TYPE, TestBlockEntity::tick);
                
        // to pass over different parameters, use a Lambda Expression instead of the method reference (TestBlockEntity::tick)
        // and change the parameters in the BlockEntity's definition of this method to your liking

        // if you struggle with writing Lambda Expressions, you can generate the structure of them in the IntelliJ IDE. [CTRL / CMD + Space]
    }
}
```

Keep in mind that ticking BlockEntities in large quantities can cause massive client lag (FPS) and/or server lag (TPS). This is one of the reasons why players place composters on top of their hoppers in large redstone contraptions.

<!--
custom rendering might need toUpdatePacket and toInitialChunkDataNbt to inform the client regarding the custom data
TODO: add this as a new section and create an example, just like the ticking section?
 -->

## Next Steps

- Create a Block, which explodes after it hasn't been interacted with for a whole day _(Hint: `world.getTimeOfDay()`)_ 
- Try experimenting with the `BlockEntity`'s NBT data. Can you save the `Entity`, which has interacted with the custom Block, and use this information? _(Hint: UUID)_
- Make a custom Block, which spawns a hostile Entity group nearby (e.g. five Zombies) and rewards the player upon defeating it.
